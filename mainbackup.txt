package main

/*
Version: 0.0.4
Author: Mang Zhang, Shenzhen China
Release Date: 2025-11-08
Project Name: GoEasyJson
Description: A tool to help fast and automatically create json server and generate test data.
Copy Rights: MIT License
Email: m13692277450@outlook.com
Mobile: +86-13692277450
HomePage: www.pavogroup.top , github.com/13692277450
*/
import (
	"embed"
	"encoding/json"
	"flag"
	"fmt"
	"io/fs"
	"io/ioutil"
	"log"
	"math"
	"math/rand"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/brianvoe/gofakeit/v7"
	"github.com/charmbracelet/lipgloss"
	"github.com/fsnotify/fsnotify"
	"github.com/gin-gonic/gin"
	"github.com/gorilla/mux"
	"github.com/gorilla/websocket"
)

//go:embed static/*
var staticFiles embed.FS
var StringEvent string = ""

// getStaticFS returns a filesystem for the static files
func getStaticFS() http.FileSystem {
	staticFS, err := fs.Sub(staticFiles, "static")
	if err != nil {
		log.Fatal(err)
	}
	return http.FS(staticFS)
}

var (
	router     *mux.Router
	routes     = make(map[string]bool)
	routesLock sync.RWMutex
	port       int
	watcher    *fsnotify.Watcher
	genjson    string
	out        string
	qty        int
)

var Red = lipgloss.NewStyle().Foreground(lipgloss.Color("#b507eaff"))
var LightGreen = lipgloss.NewStyle().Foreground(lipgloss.Color("#61f882ff"))
var LightYellow = lipgloss.NewStyle().Foreground(lipgloss.Color("#f6f349ff"))

// excludedExtensions is a map of file extensions to exclude from scanning and serving.

var excludedExtensions = map[string]bool{
	".exe": true,
	".cmd": true,
	".bat": true,
	".msi": true,
	".rar": true,
	".zip": true,
	".7z":  true,
	".log": true,
	".go":  true,
}

var (
	CurrentVersion = "0.0.4"
	IsUpgrade      = flag.Bool("upgrade", false, "Run with -upgrade to update to new version of GoEasyJson")
	// GenJson        = flag.String("genjson", "", "Generate test JSON data from sample file (e.g. -genjson sample.json -out test.json -qty 1000)")
	// OutputFile     = flag.String("out", "", "Output file for generated JSON data")
	// Quantity       = flag.Int("qty", 0, "Number of records to generate")
)

func init() {
	flag.StringVar(&genjson, "genjson", "", "Generate test JSON data from sample file (e.g. -genjson sample.json -out test.json -qty 1000)")
	flag.StringVar(&out, "out", "", "Output file for generated JSON data")
	flag.IntVar(&qty, "qty", 0, "Number of records to generate")
	flag.IntVar(&port, "port", 2006, "Server port (e.g. goeasyjson -port 2006)")

}

// 定义一个函数来安全地更新StringEvent并广播
// Declare Broadcast channel for event updates (moved earlier)
var Broadcast = make(chan string) // 广播通道

var UpdateStringEvent = func(newEvent string) {
	for route := range routes {
		var strRoute = strings.Split(route, " ")
		//StringEvent += "\n" + "http://localhost" + strRoute[0] + "\n"
		for i := 0; i < len(strRoute); i++ {
			StringEvent += "http://localhost" + strRoute[i] + "\n"
		}
		Broadcast <- StringEvent
	}
}

// Scan files and update routes based on JSON files in the current directory.
func scanDirectory() {
	currentDir, err := os.Getwd()
	if err != nil {
		Lg.Errorf("Error getting current directory: %v", err)
		return
	}
	Lg.Infof("Current directory: %s", currentDir)
	Lg.Info("Scanning directory for JSON files...")

	files, err := ioutil.ReadDir(currentDir)
	if err != nil {
		Lg.Errorf("Error reading directory: %v", err)
		return
	}

	newRoutes := make(map[string]bool)

	for _, file := range files {
		if file.IsDir() {
			continue // bypass files in directories
		}

		ext := strings.ToLower(filepath.Ext(file.Name()))
		if excludedExtensions[ext] {
			continue // bypass excluded file extensions
		}

		// For JSON file create route

		if strings.ToLower(ext) == ".json" {
			routePath := "/" + strings.TrimSuffix(file.Name(), ext)
			newRoutes[routePath] = true
		}
	}

	// Update routes

	updateRoutes(newRoutes)
}

// Update routes configuration based on new routes.
func updateRoutes(newRoutes map[string]bool) {
	routesLock.Lock()
	defer routesLock.Unlock()

	// Add new routes
	for route := range newRoutes {
		if !routes[route] {
			log.Printf("Adding new route: %s", route)
			Lg.Infof("Adding new route: %s", route)
			//UpdateStringEvent(fmt.Sprintf("Adding new route: %s", routes) + " \n ")

			router.HandleFunc(route, createFileHandler(route)).Methods("GET")
			routes[route] = true
		}
	}

	// Remote routes that no longer exist
	for route := range routes {
		if !newRoutes[route] {
			Lg.Infof("Route %s no longer exists", route)

			delete(routes, route)
		}
	}
}

// File process
func createFileHandler(route string) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		filename := strings.TrimPrefix(route, "/") + ".json"
		content, err := ioutil.ReadFile(filename)
		if err != nil {
			Lg.Errorf("Error reading file %s: %v", filename, err)
			http.Error(w, "File not found", http.StatusNotFound)
			return
		}

		// Setup response headers
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write(content)
		log.Printf("The Json response route %s was responsed success.", filename)
		Lg.Infof("The Json response route %s was responsed success.", filename)
	}
}

// Initialize file watcher and start monitoring for JSON files only.
func initFileWatcher(UpdateStringEvent func(string)) error {
	var err error
	watcher, err = fsnotify.NewWatcher()
	if err != nil {
		return fmt.Errorf("failed to create file watcher: %v", err)
	}

	// Get current directory path
	currentDir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current directory: %v", err)
	}

	// Add watch for current directory
	err = watcher.Add(currentDir)
	if err != nil {
		return fmt.Errorf("failed to add watch for directory %s: %v", currentDir, err)
	}

	log.Printf("File watcher initialized, monitoring directory %s for JSON files only", currentDir)
	Lg.Info("File watcher initialized, monitoring directory for JSON files only")
	lastEvent := make(map[string]fsnotify.Op)

	// Start file watcher event loop
	go func() {
		for {
			select {
			case event, ok := <-watcher.Events:
				if !ok {
					return
				}

				// Get file names and converto lowercase extension
				ext := strings.ToLower(filepath.Ext(event.Name))
				// Only porcess JSON files
				if ext == ".json" {
					switch event.Op {
					case fsnotify.Create:
						// Make sure it's a file and not a directory
						if info, err := os.Stat(event.Name); err == nil {
							if !info.IsDir() {
								// New json file was created, add watch for it
								err := watcher.Add(event.Name)
								if err != nil {
									Lg.Errorf("Failed to add watch for new JSON file %s: %v", event.Name, err)
									log.Printf("Failed to add watch for new JSON file %s: %v", event.Name, err)
									UpdateStringEvent(event.Name + " \n ")
								} else {
									Lg.Infof("Added watch for new JSON file: %s", event.Name)
									log.Printf("Added watch for new JSON file: %s", event.Name)
									UpdateStringEvent(event.Name + " \n ")

									scanDirectory()
								}
							}
						}

					case fsnotify.Write:
						if lastOp, exists := lastEvent[event.Name]; !exists || lastOp != event.Op {
							lastEvent[event.Name] = event.Op
						} else {
							Lg.Infof("Detect changes in JSON file: %s", event.Name)
							log.Printf("Detected changes in JSON file: %s", event.Name)
						}
						// delayed scan to avoid rapid consecutive changes
						time.AfterFunc(600*time.Millisecond, func() {
							scanDirectory()
						})
					case fsnotify.Remove:
						if lastOp, exists := lastEvent[event.Name]; !exists || lastOp != event.Op {
							lastEvent[event.Name] = event.Op
						} else {
							Lg.Infof("JSON file removed: %s", event.Name)
							log.Printf("JSON file removed: %s", event.Name)
							UpdateStringEvent(event.Name + " \n ")
						}
						// json file was removed, remove watch
						scanDirectory()
					case fsnotify.Rename:
						if lastOp, exists := lastEvent[event.Name]; !exists || lastOp != event.Op {
							lastEvent[event.Name] = event.Op
						} else {
							Lg.Infof("JSON file renamed: %s", event.Name)
							log.Printf("JSON file renamed: %s", event.Name)
						}
						scanDirectory()
					}
				} else if event.Op&fsnotify.Create == fsnotify.Create {
					// Process new folder
					if info, err := os.Stat(event.Name); err == nil {
						if info.IsDir() {
							// Create watch for new directory
							err := watcher.Add(event.Name)
							if err != nil {
								Lg.Warnf("Failed to add watch for new directory %s: %v", event.Name, err)
								log.Printf("Failed to add watch for new directory %s: %v", event.Name, err)
							}
						}
					}
				}

			case err, ok := <-watcher.Errors:
				if !ok {
					return
				}
				Lg.Errorf("File watcher error: %v", err)
			}
		}
	}()

	return nil
}
func main() {
	flag.Parse()

	// Check if we need to generate JSON data
	if genjson != "" && out != "" && qty > 0 {
		generateTestData(genjson, out, qty)
		return
	}

	fmt.Println("---------------------------------------------------------------------------")
	fmt.Println(LightGreen.Render("GoEasyJson version 0.0.4(11/19/2025), Author: Mang Zhang, Shenzhen, China"))
	fmt.Println(LightGreen.Render("Source code: github.com/13692277450/goeasyjson, HomePage: www.pavogroup.top"))
	fmt.Println("---------------------------------------------------------------------------")
	fmt.Println("GoEasyJson has file watch function to monitor new json files automatically.")
	fmt.Println("Just put your new Json file in the same directory as this program,\nit will be served automatically.")
	fmt.Println("")
	fmt.Println(Red.Render("Fake data generator: goeasyjson -genjson sample.json -out test.json -qty 1000."))
	fmt.Println(Red.Render("Customize API port: goeasyjson -port 2006."))
	fmt.Println(Red.Render("Upgrade to new version: goeasyjson -upgrade."))

	fmt.Println("---------------------------------------------------------------------------")

	LogrusConfigInit()
	go NewVersionCheck()
	fmt.Println(Cyan.Render("GoEasyJson is checking new version and initiallizing, pls wait 3 seconds..."))
	time.Sleep(time.Second * 3)
	fmt.Println(LightYellow.Render(NewVersionIsAvailable))
	fmt.Println("")
	if *IsUpgrade {
		DownlaodOption() // download new version
		os.Exit(0)
	}
	if _, err := os.Stat("goeasyjson.exe.old"); os.IsNotExist(err) {
	} else {
		os.Remove("goeasyjson.exe.old")
		fmt.Printf("The old version application was removed success.\n")
	}
	if _, err := os.Stat("goeasyjsonLinuxVersion.old"); os.IsNotExist(err) {
	} else {
		os.Remove("goeasyjsonLinuxVersion.old")
		fmt.Printf("The old version application was removed success.\n")
	}
	if _, err := os.Stat("goeasyjsonLinuxVersion.old"); os.IsNotExist(err) {
	} else {
		os.Remove("goeasyjsonMacVersion.old")
		fmt.Printf("The old version application was removed success.\n")
	}
	// Initialize router
	router = mux.NewRouter()

	// Define UpdateStringEvent function before usage (moved earlier)

	// Initialize file watcher and start monitoring for changes.
	err := initFileWatcher(UpdateStringEvent)
	if err != nil {
		log.Printf("Failed to initialize file watcher: %v", err)
		log.Println("Falling back to periodic scanning only")
	} else {
		defer watcher.Close()
	}

	// Start Scan files
	scanDirectory()
	log.Println("Folder scan completed.")

	// Version check channel
	// versionChan := make(chan string)
	// go func() {
	// 	versionChan <- NewVersionCheck()
	// }()

	// Setup periodic scanning every 60 seconds as backup solution
	ticker := time.NewTicker(60 * time.Second)
	defer ticker.Stop()

	go func() {
		for range ticker.C {
			scanDirectory()
		}
	}()

	// Add health check endpoint
	router.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		response := map[string]string{"status": "ok", "message": "Server is running"}
		log.Printf("Health check endpoint successed.")
		json.NewEncoder(w).Encode(response)
	}).Methods("GET")

	// 添加静态文件路由，使用嵌入的文件系统
	staticFS := getStaticFS()
	router.PathPrefix("/static/").Handler(http.StripPrefix("/static/", http.FileServer(staticFS)))

	// WebSocket连接管理
	var clients = make(map[*websocket.Conn]bool) // 已连接的客户端
	// Broadcast channel already declared earlier

	// WebSocket升级器
	var upgrader = websocket.Upgrader{
		CheckOrigin: func(r *http.Request) bool {
			return true // 允许所有来源
		},
	}

	// 处理WebSocket连接
	router.HandleFunc("/ws", func(w http.ResponseWriter, r *http.Request) {
		// 升级HTTP连接为WebSocket连接
		conn, err := upgrader.Upgrade(w, r, nil)
		if err != nil {
			log.Println(err)
			return
		}
		defer conn.Close()

		// 注册新客户端
		clients[conn] = true
		log.Println("New WebSocket client connected")

		// 发送当前的StringEvent值
		conn.WriteMessage(websocket.TextMessage, []byte(StringEvent))

		// 监听客户端断开连接
		for {
			_, _, err := conn.ReadMessage()
			if err != nil {
				log.Println("WebSocket client disconnected")
				delete(clients, conn)
				break
			}
		}
	})

	// 广播消息给所有客户端
	go func() {
		for {
			// 等待新消息
			msg := <-Broadcast
			// 发送给所有客户端
			for client := range clients {
				err := client.WriteMessage(websocket.TextMessage, []byte(msg))
				if err != nil {
					log.Println(err)
					client.Close()
					delete(clients, client)
				}
			}
		}
	}()

	// 修改StringEvent更新的地方，添加广播
	originalStringEvent := StringEvent
	StringEvent = ""
	for _, event := range strings.Split(originalStringEvent, "\n") {
		if event != "" {
			StringEvent += event + "\n"
			Broadcast <- StringEvent
		}
	}

	// 使用函数更新事件
	UpdateStringEvent("")

	// Start the server
	log.Printf("Starting server on port %d...", port)
	var strPort = fmt.Sprintf("Access JSON API at http://localhost:%d/filename-without-extension\n", port)
	fmt.Println(LightYellow.Render(strPort))
	fmt.Println("Server will automatically update routes when JSON files are added/removed/modified")

	// 设置Gin为release模式，禁用调试输出
	gin.SetMode(gin.ReleaseMode)
	r := gin.Default()
	r.LoadHTMLGlob("templates/**/*")
	r.GET("/", func(c *gin.Context) {
		c.HTML(200, "index.html", nil)
	})
	// 将Gin的引擎作为根路径的处理函数添加到mux的router中
	router.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) {
		r.ServeHTTP(w, req)
		w.Write([]byte(StringEvent))
	})

	// 恢复原来的http.ListenAndServe调用，传递router参数
	err = http.ListenAndServe(":"+strconv.Itoa(port), router)
	if err != nil {
		log.Printf("Server error: %v", err)
	}

}

func generateTestData(sampleFile, outputFile string, quantity int) {
	// Read sample JSON file
	sampleData, err := ioutil.ReadFile(sampleFile)
	if err != nil {
		log.Fatalf("Error reading sample JSON file: %v", err)
	}

	// Parse sample JSON to get the structure
	var sample interface{}
	if err := json.Unmarshal(sampleData, &sample); err != nil {
		log.Fatalf("Error parsing sample JSON: %v", err)
	}

	// Generate test data
	var results []interface{}
	for i := 0; i < quantity; i++ {
		// Deep copy sample structure for each record
		sampleCopy, _ := json.Marshal(sample)
		var record interface{}
		_ = json.Unmarshal(sampleCopy, &record)
		record = fillDynamic(record, "")
		results = append(results, record)
	}

	// Write generated data to output file
	outputData, err := json.MarshalIndent(results, "", "  ")
	if err != nil {
		log.Fatalf("Error marshaling generated data: %v", err)
	}

	if err := ioutil.WriteFile(outputFile, outputData, 0644); err != nil {
		log.Fatalf("Error writing output file: %v", err)
	}

	fmt.Printf("Successfully generated %d records and saved to %s\n", quantity, outputFile)
}

func fillDynamic(v interface{}, key string) interface{} {
	switch vv := v.(type) {
	case map[string]interface{}:
		for k, val := range vv {
			vv[k] = fillDynamic(val, k)
		}
		return vv
	case []interface{}:
		for i, item := range vv {
			vv[i] = fillDynamic(item, "")
		}
		return vv
	case string:
		switch strings.ToLower(key) {
		case "name", "username", "firstname", "lastname":
			return gofakeit.Name()
		// case "number":
		// 	if _, ok := v.(int); ok {
		// 		// 整数类型，生成相同位数的随机整数
		// 		return (func() int {
		// 			numDigits := 10 // 根据需要调整位数
		// 			min := int(math.Pow10(numDigits - 1))
		// 			max := int(math.Pow10(numDigits)) - 1
		// 			return rand.Intn(max-min+1) + min
		// 		})()
		// 	}
		// 	// 如果不是int类型，则返回字符串格式的随机数字
		// 	return fmt.Sprintf("%d", rand.Intn(9000000000)+1000000000)

		case "email":
			return gofakeit.Email()
		// case "grade":
		// 	return rand.Intn(100) // Grade between 1 and 100
		// case "age":
		// 	return rand.Intn(100) // Age between 1 and 99
		case "gender":
			return gofakeit.Gender()
		case "address":
			return gofakeit.Address()
		case "phone", "telephone":
			return gofakeit.Phone()
		case "city":
			return gofakeit.City()
		case "country":
			return gofakeit.Country()
		case "state":
			return gofakeit.State()
		case "streetaddress":
			return gofakeit.Street()
		case "zipcode", "postcode":
			return gofakeit.Zip()
		case "company":
			return gofakeit.Company()
		case "jobtitle", "title":
			return gofakeit.JobTitle()
		case "date", "dob", "birthdate":
			return gofakeit.Date().Format("2006-01-02")
		case "datetime", "timestamp":
			return gofakeit.Date().Format(time.RFC3339)
		case "url", "website":
			return gofakeit.URL()
		case "color":
			return gofakeit.Color()
		case "uuid", "id":
			return gofakeit.UUID()
		case "latitude":
			return gofakeit.Latitude()
		case "longitude":
			return gofakeit.Longitude()
		case "word":
			return gofakeit.Word()
		case "sentence":
			return gofakeit.Sentence()
		case "paragraph":
			return gofakeit.Paragraph()
		case "creditcardnumber":
			// gofakeit.CreditCardNumber may not be available in all versions; use CreditCard() and return Number field
			cc := gofakeit.CreditCard()
			return cc.Number
		case "creditcardtype":
			return gofakeit.CreditCardType()
		case "creditcardexpirationdate":
			return gofakeit.CreditCardExp()
		case "creditcardholdername":
			// return a realistic person name as card holder
			return gofakeit.Name()

		case "creditcardexpirationmonth":
			return gofakeit.Month()
		case "creditcardexpirationyear":
			return gofakeit.Year()
		case "quantity":
			return rand.Intn(1000000) // Quantity between 0 and 999999
		case "price", "amount":
			return fmt.Sprintf("%.2f", gofakeit.Price(1, 1000)) // Price between 1.00 and 1000.00
		case "currency":
			return gofakeit.CurrencyShort()
		case "ip":
			return gofakeit.IPv4Address()
		case "ipv6":
			return gofakeit.IPv6Address()
		case "macaddress":
			return gofakeit.MacAddress()
		case "mac":
			return gofakeit.MacAddress()
		case "password":
			return gofakeit.Password(true, true, true, true, true, 12)
			// Add more cases for other fields as needed...
		case "day":
			return gofakeit.Day()
		case "month":
			return gofakeit.Month()
		case "year":
			return gofakeit.Year()
		case "companysuffix":
			return gofakeit.CompanySuffix()
		case "unit":
			return gofakeit.Unit()
		case "area":
			return rand.Float64() * 10000 // Area between 0.00 and 10000.00
		case "street":
			return gofakeit.Street()
		case "rich":
			return gofakeit.Bool()
		default:
			return gofakeit.Word()
		}
	case bool:
		return rand.Intn(2) == 1
	default:
		// 根据源数据类型生成相应长度的随机数
		switch value := v.(type) {
		case float64:
			// 根据原始值的小数位数保留对应位数
			// 将原始值转换为字符串以确定小数位数
			str := strconv.FormatFloat(value, 'f', -1, 64)
			parts := strings.Split(str, ".")
			decimalPlaces := 0
			if len(parts) > 1 {
				decimalPlaces = len(parts[1])
			}

			// 生成0-100之间的随机数
			randomValue := rand.Float64() * 100

			// 根据原始小数位数保留对应位数
			if decimalPlaces > 0 {
				multiplier := math.Pow10(decimalPlaces)
				return math.Round(randomValue*multiplier) / multiplier
			}
			// 如果是整数，则返回整数
			return math.Round(randomValue)
		case int, int8, int16, int32, int64:
			// 整数类型，生成相同位数的随机整数
			numDigits := len(fmt.Sprintf("%d", value))
			min := int(math.Pow10(numDigits - 1))
			max := int(math.Pow10(numDigits)) - 1
			return rand.Intn(max-min+1) + min
		default:
			// 其他类型，使用原来的逻辑
			return generateRandomValue(key)
		}
	}
}

func generateRandomValue(key string) interface{} {
	// Generate a random number and append to key name
	randNum := rand.Intn(9000000) + 1000000 // 7-digit random number
	return fmt.Sprintf("%s%d", key, randNum)
}
